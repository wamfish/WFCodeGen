/// <auto-generated/>
using WFLib;
using Godot;
using System;
namespace WFCodeGen;
public partial class AppConfig : Data
{
	protected override void OnBaseConstruct()
	{
		Init();
	}
	public override int FieldCount => 10;
	public AppConfig Rent()=>DataFactory<AppConfig>.Rent();
	~AppConfig() => Dispose();
	public override void Dispose()
	{
		DataFactory<AppConfig>.Return(this);
		base.Dispose();
	}
	public override bool IsRecord => false;
	public partial class DataField : DataField<AppConfig>
	{
		public DataField(int field)
		{
			Field=field;
		}
		public int WebServerPort => Data.WebServerPort;
		public string WebServerAddress => Data.WebServerAddress;
		public int WebServerTunnelPort => Data.WebServerTunnelPort;
		public int WebServerLocalPort => Data.WebServerLocalPort;
		public string LocalServerAddress => Data.LocalServerAddress;
		public int LocalServerPort => Data.LocalServerPort;
		public int LocalServerTunnelPort => Data.LocalServerTunnelPort;
		public string TunnelKeysPassword => Data.TunnelKeysPassword;
		public string GitignoreSourceDir => Data.GitignoreSourceDir;
		public SERVERTYPE ServerType => Data.ServerType;
	}
	public override void Clear()
	{
		WebServerPort = 0;
		WebServerAddress = string.Empty;
		WebServerTunnelPort = 0;
		WebServerLocalPort = 0;
		LocalServerAddress = string.Empty;
		LocalServerPort = 0;
		LocalServerTunnelPort = 0;
		TunnelKeysPassword = string.Empty;
		GitignoreSourceDir = string.Empty;
		ServerType = 0;
		OnClear();
	}
	public override void Init()
	{
		WebServerPort = 0;
		WebServerAddress = string.Empty;
		WebServerTunnelPort = 0;
		WebServerLocalPort = 0;
		LocalServerAddress = string.Empty;
		LocalServerPort = 0;
		LocalServerTunnelPort = 0;
		TunnelKeysPassword = string.Empty;
		GitignoreSourceDir = string.Empty;
		ServerType = 0;
		OnInitialize();
	}
	public override void CopyTo(Data toData)
	{
		if (!(toData is AppConfig to)) return;
		to.Clear();
		to.WebServerPort = WebServerPort;
		to.WebServerAddress = WebServerAddress;
		to.WebServerTunnelPort = WebServerTunnelPort;
		to.WebServerLocalPort = WebServerLocalPort;
		to.LocalServerAddress = LocalServerAddress;
		to.LocalServerPort = LocalServerPort;
		to.LocalServerTunnelPort = LocalServerTunnelPort;
		to.TunnelKeysPassword = TunnelKeysPassword;
		to.GitignoreSourceDir = GitignoreSourceDir;
		to.ServerType = ServerType;
	}
	public override void FieldCopyTo(Data toData, int field)
	{
		if (!(toData is AppConfig to)) return;
		switch(field)
		{
			case 0:to.WebServerPort = WebServerPort; return;
			case 1:to.WebServerAddress = WebServerAddress; return;
			case 2:to.WebServerTunnelPort = WebServerTunnelPort; return;
			case 3:to.WebServerLocalPort = WebServerLocalPort; return;
			case 4:to.LocalServerAddress = LocalServerAddress; return;
			case 5:to.LocalServerPort = LocalServerPort; return;
			case 6:to.LocalServerTunnelPort = LocalServerTunnelPort; return;
			case 7:to.TunnelKeysPassword = TunnelKeysPassword; return;
			case 8:to.GitignoreSourceDir = GitignoreSourceDir; return;
			case 9:to.ServerType = ServerType; return;
		}
	}
	public override void WriteToBuf(SerializationBuffer sb, bool append=false)
	{
		if (!append) sb.Clear();
		if (WebServerPort != default)
		{
			sb.WriteSize(0);
			sb.Write(WebServerPort);
		}
		if (WebServerAddress != default)
		{
			sb.WriteSize(1);
			sb.Write(WebServerAddress);
		}
		if (WebServerTunnelPort != default)
		{
			sb.WriteSize(2);
			sb.Write(WebServerTunnelPort);
		}
		if (WebServerLocalPort != default)
		{
			sb.WriteSize(3);
			sb.Write(WebServerLocalPort);
		}
		if (LocalServerAddress != default)
		{
			sb.WriteSize(4);
			sb.Write(LocalServerAddress);
		}
		if (LocalServerPort != default)
		{
			sb.WriteSize(5);
			sb.Write(LocalServerPort);
		}
		if (LocalServerTunnelPort != default)
		{
			sb.WriteSize(6);
			sb.Write(LocalServerTunnelPort);
		}
		if (TunnelKeysPassword != default)
		{
			sb.WriteSize(7);
			sb.Write(TunnelKeysPassword);
		}
		if (GitignoreSourceDir != default)
		{
			sb.WriteSize(8);
			sb.Write(GitignoreSourceDir);
		}
		if (ServerType != default)
		{
			sb.WriteSize(9);
			sb.Write((byte)ServerType);
		}
		sb.WriteSize(-1);
	}
	/// <summary>
	/// ReadFromBuf loads the data from the buffer into the object. 
	/// maxField is used by Table.Filter to only load the fields that are needed.
	/// </summary>
	public override void ReadFromBuf(SerializationBuffer sb, int maxField)
	{
		Clear();
		int fieldIndex;
		fieldIndex = sb.ReadSize();
		if (fieldIndex > maxField) return; 
		if (fieldIndex == 0)
		{
			WebServerPort = sb.ReadInt();
			fieldIndex = sb.ReadSize();
			if (fieldIndex > maxField) return;
		}
		if (fieldIndex == 1)
		{
			WebServerAddress = sb.ReadString();
			fieldIndex = sb.ReadSize();
			if (fieldIndex > maxField) return;
		}
		if (fieldIndex == 2)
		{
			WebServerTunnelPort = sb.ReadInt();
			fieldIndex = sb.ReadSize();
			if (fieldIndex > maxField) return;
		}
		if (fieldIndex == 3)
		{
			WebServerLocalPort = sb.ReadInt();
			fieldIndex = sb.ReadSize();
			if (fieldIndex > maxField) return;
		}
		if (fieldIndex == 4)
		{
			LocalServerAddress = sb.ReadString();
			fieldIndex = sb.ReadSize();
			if (fieldIndex > maxField) return;
		}
		if (fieldIndex == 5)
		{
			LocalServerPort = sb.ReadInt();
			fieldIndex = sb.ReadSize();
			if (fieldIndex > maxField) return;
		}
		if (fieldIndex == 6)
		{
			LocalServerTunnelPort = sb.ReadInt();
			fieldIndex = sb.ReadSize();
			if (fieldIndex > maxField) return;
		}
		if (fieldIndex == 7)
		{
			TunnelKeysPassword = sb.ReadString();
			fieldIndex = sb.ReadSize();
			if (fieldIndex > maxField) return;
		}
		if (fieldIndex == 8)
		{
			GitignoreSourceDir = sb.ReadString();
			fieldIndex = sb.ReadSize();
			if (fieldIndex > maxField) return;
		}
		if (fieldIndex == 9)
		{
			ServerType = (SERVERTYPE) sb.ReadByte();
			fieldIndex = sb.ReadSize();
			if (fieldIndex > maxField) return;
		}
		// no need to do OnLoad we are in a filter
	}
	/// <summary>
	/// ReadFromBuf loads the data from the buffer into the object. 
	/// </summary>
	public override void ReadFromBuf(SerializationBuffer sb)
	{
		Clear();
		int fieldIndex;
		fieldIndex = sb.ReadSize();
		if (fieldIndex == 0)
		{
			WebServerPort = sb.ReadInt();
			fieldIndex = sb.ReadSize();
		}
		if (fieldIndex == 1)
		{
			WebServerAddress = sb.ReadString();
			fieldIndex = sb.ReadSize();
		}
		if (fieldIndex == 2)
		{
			WebServerTunnelPort = sb.ReadInt();
			fieldIndex = sb.ReadSize();
		}
		if (fieldIndex == 3)
		{
			WebServerLocalPort = sb.ReadInt();
			fieldIndex = sb.ReadSize();
		}
		if (fieldIndex == 4)
		{
			LocalServerAddress = sb.ReadString();
			fieldIndex = sb.ReadSize();
		}
		if (fieldIndex == 5)
		{
			LocalServerPort = sb.ReadInt();
			fieldIndex = sb.ReadSize();
		}
		if (fieldIndex == 6)
		{
			LocalServerTunnelPort = sb.ReadInt();
			fieldIndex = sb.ReadSize();
		}
		if (fieldIndex == 7)
		{
			TunnelKeysPassword = sb.ReadString();
			fieldIndex = sb.ReadSize();
		}
		if (fieldIndex == 8)
		{
			GitignoreSourceDir = sb.ReadString();
			fieldIndex = sb.ReadSize();
		}
		if (fieldIndex == 9)
		{
			ServerType = (SERVERTYPE) sb.ReadByte();
			fieldIndex = sb.ReadSize();
		}
		OnLoad();
	}
	public override bool FieldIsDefault(int field)
	{
		switch(field)
		{
			case 0:return WebServerPort == default;
			case 1:return WebServerAddress == string.Empty;
			case 2:return WebServerTunnelPort == default;
			case 3:return WebServerLocalPort == default;
			case 4:return LocalServerAddress == string.Empty;
			case 5:return LocalServerPort == default;
			case 6:return LocalServerTunnelPort == default;
			case 7:return TunnelKeysPassword == string.Empty;
			case 8:return GitignoreSourceDir == string.Empty;
			case 9:return ServerType == default;
		}
		return false;
	}
	public override bool FieldIsEqual(Data toFld, int field)
	{
		if (!(toFld is AppConfig to)) return false;
		switch(field)
		{
			case 0:return WebServerPort == to.WebServerPort;
			case 1:return WebServerAddress == to.WebServerAddress;
			case 2:return WebServerTunnelPort == to.WebServerTunnelPort;
			case 3:return WebServerLocalPort == to.WebServerLocalPort;
			case 4:return LocalServerAddress == to.LocalServerAddress;
			case 5:return LocalServerPort == to.LocalServerPort;
			case 6:return LocalServerTunnelPort == to.LocalServerTunnelPort;
			case 7:return TunnelKeysPassword == to.TunnelKeysPassword;
			case 8:return GitignoreSourceDir == to.GitignoreSourceDir;
			case 9:return ServerType == to.ServerType;
		}
		return false;
	}
	public override string FieldAsString(int field)
	{
		switch(field)
		{
			case 0:return WebServerPort.AsString();
			case 1:return WebServerAddress;
			case 2:return WebServerTunnelPort.AsString();
			case 3:return WebServerLocalPort.AsString();
			case 4:return LocalServerAddress;
			case 5:return LocalServerPort.AsString();
			case 6:return LocalServerTunnelPort.AsString();
			case 7:return TunnelKeysPassword;
			case 8:return GitignoreSourceDir;
			case 9:return ServerType.ToString();
		}
		return string.Empty;
	}
	public override void FieldFromString(string str, int field)
	{
		switch(field)
		{
			case 0:WebServerPort = str.AsInt(); return;
			case 1:WebServerAddress = str; return;
			case 2:WebServerTunnelPort = str.AsInt(); return;
			case 3:WebServerLocalPort = str.AsInt(); return;
			case 4:LocalServerAddress = str; return;
			case 5:LocalServerPort = str.AsInt(); return;
			case 6:LocalServerTunnelPort = str.AsInt(); return;
			case 7:TunnelKeysPassword = str; return;
			case 8:GitignoreSourceDir = str; return;
			case 9:if (!Enum.TryParse<SERVERTYPE>(str, out SERVERTYPE ServerType)) ServerType = default; return;
		}
		return;
	}
	public override string FieldName(int field)
	{
		if (field < 0 || field >= FieldCount) return string.Empty;
		return FieldNames[field];
	}
	public override string FieldLabel(int field)
	{
		if (field < 0 || field >= FieldCount) return string.Empty;
		return FieldLabels[field];
	}
	public override void FieldLabelSet(int field, string label)
	{
		if (field < 0 || field >= FieldCount) return;
		FieldLabels[field] = label;
	}
	public override string FieldColumnLabel(int field)
	{
		if (field < 0 || field >= FieldCount) return string.Empty;
		return ColumnLabels[field];
	}
	public override void FieldColumnLabelSet(int field, string label)
	{
		if (field < 0 || field >= FieldCount) return;
		ColumnLabels[field] = label;
	}
	public override void FieldMinSet(int field, object min)
	{
		if (field < 0 || field >= FieldCount) return;
		Min[field] = min;
	}
	public override object FieldMin(int field)
	{
		if (field < 0 || field >= FieldCount) return 0;
		return Min[field];
	}
	public override void FieldMaxSet(int field, object max)
	{
		if (field < 0 || field >= FieldCount) return;
		Max[field] = max;
	}
	public override object FieldMax(int field)
	{
		if (field < 0 || field >= FieldCount) return 0;
		return Max[field];
	}
	public override int FieldIdFromName(string name)
	{
		if (FieldIdLookup.TryGetValue(name, out int id)) return id;
		return -1;
	}
	/// <summary>
	/// Writes to sb the field formated as a key.
	/// maxSize is used for strings only.
	/// </summary>
	public override void FieldAsKey(int field, SerializationBuffer sb, int maxSize)
	{
		switch(field)
		{
			case 0:sb.Write(WebServerPort); return;
			case 1:WebServerAddress.AsKey(sb, maxSize); return;
			case 2:sb.Write(WebServerTunnelPort); return;
			case 3:sb.Write(WebServerLocalPort); return;
			case 4:LocalServerAddress.AsKey(sb, maxSize); return;
			case 5:sb.Write(LocalServerPort); return;
			case 6:sb.Write(LocalServerTunnelPort); return;
			case 7:TunnelKeysPassword.AsKey(sb, maxSize); return;
			case 8:GitignoreSourceDir.AsKey(sb, maxSize); return;
			case 9:ServerType.ToString().AsKey(sb,maxSize); return;
		}
	}
	/// <summary>
	/// Returns the field as an object.
	/// </summary>
	public override Object FieldAsObject(int field)
	{
		switch(field)
		{
			case 0:return (Object)WebServerPort;
			case 1:return (Object)WebServerAddress;
			case 2:return (Object)WebServerTunnelPort;
			case 3:return (Object)WebServerLocalPort;
			case 4:return (Object)LocalServerAddress;
			case 5:return (Object)LocalServerPort;
			case 6:return (Object)LocalServerTunnelPort;
			case 7:return (Object)TunnelKeysPassword;
			case 8:return (Object)GitignoreSourceDir;
			case 9:return (Object)ServerType;
		}
		return null;
	}
	/// <summary>
	/// Sets the field to an object.
	/// </summary>
	public override void FieldFromObject(Object o,  int field)
	{
		switch(field)
		{
			case 0:WebServerPort = (int) o; return;
			case 1:WebServerAddress = (string) o; return;
			case 2:WebServerTunnelPort = (int) o; return;
			case 3:WebServerLocalPort = (int) o; return;
			case 4:LocalServerAddress = (string) o; return;
			case 5:LocalServerPort = (int) o; return;
			case 6:LocalServerTunnelPort = (int) o; return;
			case 7:TunnelKeysPassword = (string) o; return;
			case 8:GitignoreSourceDir = (string) o; return;
			case 9:ServerType = (SERVERTYPE) o; return;
		}
	}
	/// <summary>
	/// Returns the field Type.
	/// </summary>
	public override Type FieldType(int field)
	{
		switch(field)
		{
			case 0:return WebServerPort.GetType();
			case 1:return WebServerAddress.GetType();
			case 2:return WebServerTunnelPort.GetType();
			case 3:return WebServerLocalPort.GetType();
			case 4:return LocalServerAddress.GetType();
			case 5:return LocalServerPort.GetType();
			case 6:return LocalServerTunnelPort.GetType();
			case 7:return TunnelKeysPassword.GetType();
			case 8:return GitignoreSourceDir.GetType();
			case 9:return ServerType.GetType();
		}
		return null;
	}
	public partial class Context : DataContext<AppConfig>
	{
		protected override void OnBaseConstruct()
		{
			Data = DataFactory<AppConfig>.Rent();
		}
		public static Context Rent() => (Context) DataContextFactory<AppConfig>.Rent();
		public override void Dispose()
		{
			DataContextFactory<AppConfig>.Return(this);
		}
	}
	public static class FID
	{
		public const int WebServerPort = 0;
		public const int WebServerAddress = 1;
		public const int WebServerTunnelPort = 2;
		public const int WebServerLocalPort = 3;
		public const int LocalServerAddress = 4;
		public const int LocalServerPort = 5;
		public const int LocalServerTunnelPort = 6;
		public const int TunnelKeysPassword = 7;
		public const int GitignoreSourceDir = 8;
		public const int ServerType = 9;
	}
	static object[] Min = { (int) -2147483648,(int) 0,(int) -2147483648,(int) -2147483648,(int) 0,(int) -2147483648,(int) -2147483648,(int) 0,(int) 0,(int) 0, };
	static object[] Max = { (int) 2147483647,(int) 0,(int) 2147483647,(int) 2147483647,(int) 0,(int) 2147483647,(int) 2147483647,(int) 0,(int) 0,(int) 0, };
	static string[] FieldLabels =
	{
		"Web Server Port",
		"Web Server Address",
		"Web Server Tunnel Port",
		"Web Server Local Port",
		"Local Server Address",
		"Local Server Port",
		"Local Server Tunnel Port",
		"Tunnel Keys Password",
		"Gitignore Source Dir",
		"Server Type",
	};
	static string[] ColumnLabels =
	{
		"Web Server Port",
		"Web Server Address",
		"Web Server Tunnel Port",
		"Web Server Local Port",
		"Local Server Address",
		"Local Server Port",
		"Local Server Tunnel Port",
		"Tunnel Keys Password",
		"Gitignore Source Dir",
		"Server Type",
	};
	static Dictionary<string, int> FieldIdLookup = new()
	{
		{ "WebServerPort", 0 },
		{ "WebServerAddress", 1 },
		{ "WebServerTunnelPort", 2 },
		{ "WebServerLocalPort", 3 },
		{ "LocalServerAddress", 4 },
		{ "LocalServerPort", 5 },
		{ "LocalServerTunnelPort", 6 },
		{ "TunnelKeysPassword", 7 },
		{ "GitignoreSourceDir", 8 },
		{ "ServerType", 9 },
	};
	static string[] FieldNames =
	{
		"WebServerPort",
		"WebServerAddress",
		"WebServerTunnelPort",
		"WebServerLocalPort",
		"LocalServerAddress",
		"LocalServerPort",
		"LocalServerTunnelPort",
		"TunnelKeysPassword",
		"GitignoreSourceDir",
		"ServerType",
	};
	static string[] TypeNames =
	{
		"int",
		"string",
		"int",
		"int",
		"string",
		"int",
		"int",
		"string",
		"string",
		"SERVERTYPE",
	};
	public override string[] StaticTypeNames => TypeNames;
	static List<ValidationFunc>[] ValidationFuncs = new List<ValidationFunc>[10];
	public override List<ValidationFunc>[] StaticValidationFuncs => ValidationFuncs;
	static Func<Data,string>[] HtmlHelpers = new Func<Data,string>[10];
	public override Func<Data,string>[] StaticHtmlHelpers => HtmlHelpers;
	public partial class Util : DataUtil<AppConfig>
	{
	}
}
